/* autogenerated by Processing revision 1289 on 2023-05-22 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class MiniGameGame extends PApplet {

private GameModule currentModule;
private GameModule[] moduleCollection ={new Peggle(), new Tetris()};

public static int currentModuleNum;

boolean[] downKeys = new boolean[256];
boolean[] downCodedKeys = new boolean[256];

World[][] worldOne;
char[][] pgrid;
Player player = new Player();

int squaresize = 50;

boolean q = false;

public void SwitchModule(int i)
{
  if (i >= moduleCollection.length) return;
  if (currentModule != null); //EXIT
  currentModule = moduleCollection[i];
  currentModule.Enter();
  currentModuleNum = i;
}
public void NextModule()
{
  SwitchModule(currentModuleNum + 1);
}

public void setup()
{
  /* size commented out by preprocessor */;
  
  surface.setResizable(true);
  for (int i = 0; i < moduleCollection.length; i++)
  {
    moduleCollection[i].Setup();
  }
  SwitchModule(0);
}


boolean mouseIsPressed = false;
public void draw()
{
  if (currentModule == null) return;
  currentModule.Draw();

  if (currentModule.isDone)
  {
    if(!q) {

    NextModule();
    q = true;
    }
    else {
      println("Victory!!!");
    }
  }


  if (mousePressed == true)
    currentModule.MouseInput(mouseX, mouseY, MouseInputFlags.pressedDown);

  else if (mousePressed == false && mouseIsPressed == true)
    currentModule.MouseInput(mouseX, mouseY, MouseInputFlags.released);

  else
    currentModule.MouseInput(mouseX, mouseY, MouseInputFlags.none);

  mouseIsPressed = mousePressed;
}
public void keyPressed() {
  if (key == CODED) {
    //print("Code: " + keyCode + ". ");
    if (keyCode<256) {

      downCodedKeys[keyCode] = true;
    }
  } else {
    //print("Key: " + (int)key + ". ");
    if (key<256) {
      downKeys[key] = true;
    }
  }
}
public void keyReleased() {
  if (key == CODED) {
    //print("LiftCode: " + keyCode + ". ");
    if (keyCode<256) {
      downCodedKeys[keyCode] = false;
    }
  } else {
    //print("LiftKey: " + (int)key + ". ");
    if (key<256) {
      downKeys[key] = false;
    }
  }
}
public class MapObjects
{
}
public enum MouseInputFlags
{
  pressedDown, released, hold, none
}
public abstract class GameModule
{
  public boolean isDone = false;
  public void MouseInput(float x, float y, MouseInputFlags clickFlag)
  {
    //This is empty for inheritance reasons
  }
  public void Setup()
  {
    //This is empty for inheritance reasons
  }
  public abstract void Draw();
  public abstract void Enter();
  public abstract void Exit();
}

public class Peggle extends GameModule
{
  Ball ball = new Ball();

  Target[] targets = {new Target(100, 100), new Target(150, 100), new Target(200, 100), new Target(250, 100), new Target(300, 100),
    new Target(350, 100), new Target(400, 100), new Target(450, 100), new Target(500, 100),
    new Target(100, 150), new Target(500, 150), new Target(100, 200), new Target(500, 200), };

  float aimX;
  float aimY;

  boolean canFireAgain = true;
  float shooterX;
  float shooterY;

  float barrelA;
  float barrelX;
  float barrelY;

  PImage background;

  public void MouseInput(float x, float y, MouseInputFlags clickFlag)
  {
    aimX = x;
    aimY = y;
    barrelA = atan2(shooterY - aimY, shooterX - aimX);


    switch(clickFlag)
    {
    case pressedDown:
      if (canFireAgain)
      {
        canFireAgain = false;
        float dst = sqrt((shooterX - aimX) * (shooterX - aimX) + (shooterY - aimY) * (shooterY - aimY));
        float fireDirX = (shooterX - aimX) / dst;
        float fireDirY = (shooterY - aimY) / dst;

        ball.dirX = -fireDirX;
        ball.dirY = -fireDirY;
        ball.x = shooterX;
        ball.y = shooterY;
      } else
      {
        if (ball.isOffScreen) canFireAgain = true;
      }
      break;
    }
  }

  public void Draw()
  {
    image(background, 0, 0, width, height);

    translate(shooterX, shooterY);
    rotate(barrelA);
    rect(-10, -5, 10, 10);
    resetMatrix();

    circle(shooterX, shooterY, 10);
    if (!canFireAgain)circle(ball.x, ball.y, 10);

    ball.UpdatePos();
    ball.TargetCheck(targets);

    for (int i = 0; i < targets.length; i++)
    {
      if (targets[i] != null && !targets[i].isHit) targets[i].Draw();
    }


    isDone = ball.hits >= targets.length;
  }

  public void Enter()
  {
    shooterX = width/2;
    shooterY = height - 50;

    ball.x = shooterX;
    ball.y = shooterY;

    background = loadImage("wall.png");



    for (int i = 0; i < targets.length; i++)
    {
      targets[i].Enter();
    }
  }
  public void Exit()
  {
  }

  public void Setup()
  {

    ArrayList<Target> t = new ArrayList<Target>();
    for (int yt = 0; yt < 3; yt++)
    {
      for (int xt = 0; xt < 11; xt++)
      {
        t.add(new Target(width/2 - 250 + (50 * xt), height/2 - 150 + (50 * yt)));
      }
    }

    Target[] newT = new Target[t.size()];
    for (int i = 0; i < newT.length; i++)
    {
      newT[i] = t.get(i);
    }
    targets = newT;
  }

  class Ball
  {
    public boolean isOffScreen = true;
    public int hits = 0;

    float dirX;
    float dirY;

    float radius;
    float speed = 10;

    float x;
    float y;
    public void Fire(float _dirX, float _dirY)
    {
      dirX = _dirX;
      dirY = _dirY;
    }

    public void UpdatePos()
    {
      x += dirX * speed;
      y += dirY * speed;

      if (x <= 0 || x >= width) dirX = -dirX;
      if (y <= 0) dirY = -dirY;
      isOffScreen = y >= height;
    }

    public void TargetCheck(Target[] targets)
    {
      for (int i = 0; i < targets.length; i++)
      {
        float tx = targets[i].x;
        float ty = targets[i].y;
        float sx = targets[i].sizeX;
        float sy = targets[i].sizeY;

        if (abs(tx - x) < sx && abs(ty - y) < sy && !targets[i].isHit)
        {
          if (abs(tx - x) > abs(ty - y)) dirX = -dirX;
          else dirY = -dirY;
          targets[i].isHit = true;
          hits++;
        }
      }
    }
  }

  public class Target
  {
    float sizeX = 25;
    float sizeY = 25;

    float addSize = 25;

    float x;
    float y;

    boolean isHit = false;

    PImage texture;

    public Target(float _x, float _y)
    {
      x = _x;
      y = _y;
    }

    public void Enter()
    {
      texture = loadImage("gemstone.png");
    }

    public void Draw()
    {
      //rect(x - sizeX, y - sizeY, sizeX * 2, sizeY * 2);
      image(texture, x - sizeX, y - sizeY, sizeX + addSize, sizeY + addSize);
    }
  }
}

class World {
  byte health;
  boolean passable;
  int worldColor;

  World(boolean border) {
    health = 10;
    if (border) {
      passable = false;
    worldColor = color(125,125,125);
    }
    else {
      passable = true;
      worldColor = color(0,0,0);
    }
  }


  public void draw(int tempXdir, int tempYdir, int tempSquaresize) {
    fill(worldColor, 255*(10-(health%10)));
    square(tempXdir*tempSquaresize, tempYdir*tempSquaresize, tempSquaresize);
  }
}

class WorldObject {
  byte squaresize;
  //boolean running = true;
  PVector place = new PVector(1, 3);
  PVector direction = new PVector(1, 0);  //float xdir, ydir;
  boolean passable, destructible;
  int worldObjectColor;

  WorldObject() {
    squaresize = 50;
    passable = PApplet.parseBoolean(round(random(0, 1)));
    worldObjectColor = color(125,125,125);
    destructible = false;
  }
  public void draw() {
    fill(worldObjectColor);
    square(place.x*squaresize, place.y*squaresize, squaresize);
  }
}

class TetrisTemplate {


   PVector[][] temps = new PVector[4][4];

    
    int timeX = 0;

    int timeY = 0;

    int[][] tempsX = new int[4][4];

    int[][] tempsY = new int[4][4];



    TetrisTemplate() {

    }
    private int[] setterXY( int a, int b,int c, int d) {
        int[] lol = {a,b,c,d};
        return lol;
    }
    public TetrisTemplate setX(int a,int b,int c,int d) {
        this.tempsX[this.timeX] = this.setterXY(a,b,c,d);
        this.timeX += 1;
        return this;

    }

    public TetrisTemplate setY(int a,int b,int c,int d) {
        this.tempsY[this.timeY] = this.setterXY(a,b,c,d);
        this.timeY += 1;
        return this;
    }

    private PVector[] createTemp(int[] x, int[] y) {
        PVector[] template = new PVector[4];

        for (int i = 0; i< x.length; i++) {
            PVector point = new PVector(x[i],y[i]);
            template[i] = point;
        }        
        return template;

    }
    public PVector[][] build() {
        for(int i = 0; i< this.tempsX.length;i++){
        this.temps[i] = this.createTemp(this.tempsX[i],this.tempsY[i]);
        }
        return this.temps;
    }
}

class TetrisBlock extends FallingWO {

   Piece[] pieces = new Piece[4];


    PVector[][] temps = new PVector[4][4];


    int chosen = 1;

    TetrisBlock(PieceTmp temps2) {
        super();
        this.passable = false;
        this.temps = temps2.Temp;

        for (int i = 0; i< this.temps[chosen].length; i++) {
            Piece obj = new Piece(0);
            PVector point = this.temps[chosen][i].copy();
            point.add(this.place.copy());
            obj.place = point;
            obj.worldObjectColor = temps2.Col;

            this.pieces[i] = obj;

        }
    }


    public boolean checkAll(Piece[] pieces2) {
        boolean returner = true;
        
        for(int i = 0; i< pieces2.length;i++) {
        
        if (pieces2[i].checkDown()) {
            returner = false;
        }
        }
        return returner;
    }
    public void sync(Piece[] pieces2,PVector[][] temps2,int choice) {



        for (int i = 0; i< pieces2.length; i++) {

            pieces2[i].place = this.place.copy().add(temps2[choice][i].copy());


            pgrid[PApplet.parseInt(pieces2[i].place.x)][PApplet.parseInt(pieces2[i].place.y)] = '1'; 
    }

    }

    public void draw2(Piece[] pieces2) {
        for(WorldObject piece: pieces2) {
            piece.draw();
        }
    }

    public void update() {
        if(this.checkAll(this.pieces)) {
            this.applyGrav();
        }
        this.sync(this.pieces,this.temps,this.chosen);
    }
    public void sackoe() {

        this.sync(this.pieces,this.temps,this.chosen);
    }

    public void draw() {
    this.draw2(this.pieces);
    }
}

class Player extends FallingWO {
  int health;
  
  Player() {
    super();
    worldObjectColor = color(255, 0, 0);
    this.health = 1;
  }
  public void moveForward() {
    print(place + " : " + direction);
    if (PApplet.parseInt(place.y+direction.y)>0 && PApplet.parseInt(place.x+direction.x)>0) {
      place.add(direction);
      println(" .Now: " + place);
    }
  }
  
  private boolean checkDown() {
    
      if (pgrid[PApplet.parseInt(this.place.x)][PApplet.parseInt(this.place.y+1)] != '1') {
        return true;
      } 
      return false;
  }
  private boolean checkDown(PVector puppDir) {
    
      if (worldOne[PApplet.parseInt(this.place.x)][PApplet.parseInt(this.place.y+puppDir.y)].passable) {
        return true;
      } 
      return false;
  }
  private void appDirection(PVector direction2) {
    if (this.checkDown(direction2)) {
        this.place.add(direction2);
      }
  }
  public void applyGrav() {
      this.direction = (new PVector(0,1));

      if (pgrid[PApplet.parseInt(this.place.x)][PApplet.parseInt(this.place.y + this.direction.y)] != '1') {
        this.place.add(this.direction);
      }
  }

  public boolean isDead() {
    if (health>0) {
      return false;
    } else {
      return true;
    }
  }
  public void action() {
    PVector sumDirection = new PVector(0, 0);  //
    if (downCodedKeys[38]) {
      if (!this.checkDown()) {
      sumDirection.add(new PVector(0, -4));
      }
    }
    if (downCodedKeys[37]) {
      sumDirection.add(new PVector(-1, 0));
    }
    if (downCodedKeys[39]) {
      sumDirection.add(new PVector(1, 0));
    }
    //Can't move out of map
    if (PApplet.parseInt(player.place.x+sumDirection.x)<0 || PApplet.parseInt(player.place.x+sumDirection.x)>worldOne.length-1) {
      sumDirection.x=0;
    }
    if (PApplet.parseInt(player.place.y+sumDirection.y)<0 || PApplet.parseInt(player.place.y+sumDirection.y)>worldOne[0].length-1) {
      sumDirection.y=0;
    }
    //
    if (sumDirection.mag()>0) {
      this.direction=sumDirection;
        if (this.checkDown(this.direction)){
          if (pgrid[PApplet.parseInt(this.place.x+direction.x)][PApplet.parseInt(this.place.y)] != '1' ){ 
              this.place.add(this.direction);
          }
          else  {
            this.place.y += this.direction.y;
          }
      }
    }
    //
    pgrid[PApplet.parseInt(this.place.x+direction.x)][PApplet.parseInt(this.place.y)] = '3';
  }
}

class PieceTmp {
    PVector[][] Temp;

    int Col;

    PieceTmp(PVector[][] tmp, int col) {
        this.Temp = tmp;

        this.Col = col;
    }
}

class PieceTemps {

PieceTmp LTemp =new PieceTmp( new TetrisTemplate()
        .setX(-1,-1,0,1)
        .setY(-1,0,0,0)
        .setX(0,1,0,0)
        .setY(-1,-1,0,1)
        .setX(-1,0,1,1)
        .setY(0,0,0,1)
        .setX(-1,0,0,0)
        .setY(1,1,0,-1)
        .build(),color(49, 115, 173));
PieceTmp ZTemp =new PieceTmp( new TetrisTemplate()
        .setX(-1,0,0,1)
        .setY(0,0,1,1)
        .setX(0,0,1,1)
        .setY(-1,0,0,1)
        .setX(-1,0,0,1)
        .setY(1,1,0,0)
        .setX(-1,-1,0,0)
        .setY(-1,0,0,1)
        .build(), color(55,173,49));

PieceTmp LLTemp = new PieceTmp( new TetrisTemplate()
        .setX(-1,0,1,1)
        .setY(0,0,0,-1)
        .setX(0,0,0,1)
        .setY(-1,0,1,1)
        .setX(-1,-1,0,1)
        .setY(0,1,0,0)
        .setX(-1,0,0,0)
        .setY(-1,-1,0,1)
        .build(),color(219,130,29));

PieceTmp TTemp = new PieceTmp( new TetrisTemplate()
        .setX(-1,0,0,1)
        .setY(0,0,-1,0)
        .setX(0,0,0,1)
        .setY(-1,0,1,0)
        .setX(-1,0,0,1)
        .setY(0,0,1,0)
        .setX(-1,0,0,0)
        .setY(0,-1,0,1)
        .build(),color(168,29,219));

PieceTmp ZZTemp = new PieceTmp( new TetrisTemplate()
        .setX(-1,0,0,1)
        .setY(-1,-1,0,0)
        .setX(0,0,1,1)
        .setY(0,1,0,-1)
        .setX(-1,0,0,1)
        .setY(0,0,1,1)
        .setX(-1,-1,0,0)
        .setY(0,1,0,1)
        .build(),color(237,57,57));

PieceTmp STemp= new PieceTmp( new TetrisTemplate()
        .setX(-1,-1,0,0)
        .setY(-1,0,-1,0)
        .setX(-1,-1,0,0)
        .setY(-1,0,-1,0)
        .setX(-1,-1,0,0)
        .setY(-1,0,-1,0)
        .setX(-1,-1,0,0)
        .setY(-1,0,-1,0)
        .build(),color(242,225,34));

PieceTmp ITemp= new PieceTmp( new TetrisTemplate()
        .setX(-2,-1,0,1)
        .setY(0,0,0,0)
        .setX(0,0,0,0)
        .setY(-2,-1,0,1)
        .setX(-2,-1,0,1)
        .setY(0,0,0,0)
        .setX(0,0,0,0)
        .setY(-2,-1,0,1)
        .build(),color(139,192,232));
 
PieceTmp[] TempTypes = new PieceTmp[7];

    PieceTemps() {

        this.TempTypes[0] = this.LLTemp;
        this.TempTypes[1] = this.ZTemp;
        this.TempTypes[2] = this.TTemp;
        this.TempTypes[3] = this.LTemp;
        this.TempTypes[4] = this.ZZTemp;
        this.TempTypes[5] = this.ITemp;
        this.TempTypes[6] = this.STemp;
         

    }
    public PieceTmp getRand() {
        int rand = PApplet.parseInt(random(6));

        return this.TempTypes[rand];
    }
}

class Piece extends FallingWO {
    Piece(int x) {
        super();
        this.worldObjectColor = color(125,125,255);
        this.place.x = x;
        this.passable = false;
    }
    public boolean checkDown() {
        if(pgrid[PApplet.parseInt(this.place.x)][PApplet.parseInt(this.place.y+1)] == '1') {
            return true;
        }

        else if(pgrid[PApplet.parseInt(this.place.x)][PApplet.parseInt(this.place.y+1)] == '3') {
            player.health -= 1;
            println("Dead");
            return false;
        }
        else {
            return false;
        }
    }


}

class FallingWO extends WorldObject {
    FallingWO() {
        super();
    }

    public void applyGrav() {
        if (this.place.y  < 20 ) {
            this.place.y += 1;
        } 
    }

}
public class Tetris extends GameModule {
    


int time = 0;
int old_time = 0;
int add_time = 0;
boolean change = false;

int framerate = 10;


char[][] grid;

PieceTemps temps = new PieceTemps();


TetrisBlock[] blocks = {};

public void addBlock() {
  TetrisBlock blockman = new TetrisBlock(temps.getRand());

  int chosen = PApplet.parseInt(random(3));
  int x_place = PApplet.parseInt(random(3,8));
  blockman.place.x = x_place;
blockman.chosen = chosen;
blocks = (TetrisBlock[]) append(blocks,blockman);
  
}

boolean end = false;

public void Setup(){}

public void Exit(){}

public void Enter() {
  surface.setSize(600, 1100);
  //size(1280, 960);
  //size(1440, 900);
  //size(1600, 900);
  //size(1680, 1050);
  //size(1920, 1080);
  //fullScreen();
  addBlock();
  

  background(0);
  fill(255);
  stroke(255);
  worldOne = new World[width/50][height/50];  //x , y
  grid = new char[width/50][height/50];
  
  pgrid = new char[width/50][height/50];
  println("Dungeon size is: " + worldOne.length + " in x direction &: " + worldOne[0].length + " in y direction");
  for (int xline = squaresize; xline<width; xline+=squaresize) {
    line(xline, 0, xline, height);
  }
  for (int yline = squaresize; yline<height; yline+=squaresize) {
    line(0, yline, width, yline);
  }
  for (int ydir = 0; ydir<worldOne[0].length; ydir++) {
    for (int xdir = 0; xdir<worldOne.length; xdir++) {
      if (ydir == 0 || ydir == worldOne[0].length-1 || xdir == 0 || xdir == worldOne.length-1){
      worldOne[xdir][ydir] = new World(true);
      grid[xdir][ydir] = '1';
    pgrid[xdir][ydir] = '1';
      
    }
    else {
      worldOne[xdir][ydir] = new World(false);
      if(ydir == 3) {

        World wordlTemp =  new World(false);

    wordlTemp.worldColor = color(113,240,157);

      worldOne[xdir][ydir] = wordlTemp;

      }
      grid[xdir][ydir] = '0';
    pgrid[xdir][ydir] = '0';
      
    }
    }
  }
  
  frameRate(framerate);
  println("Finished setup @: " + millis());
}

public void Draw() {

  if(!end) {

  time = millis();


  if(time-old_time > 500 ) {

    change = true;
    old_time = time;
  
  }
  else {
    change = false;

  }
  
  if (time-add_time > 3000) {
    addBlock();
    add_time = time;
  }

  for (int i = 0; i< grid.length; i++) {
    for (int b = 0; b < grid[i].length; b++) {
      pgrid[i][b] = grid[i][b];
    }
  }





  for(TetrisBlock blocksu: blocks) {


    if(change) {
      blocksu.update();
    }

    blocksu.sackoe();
  }
  
  
  player.applyGrav();

  player.action();
  // for (int i = 0; i< pgrid.length; i++) {
  //  for (int b = 0; b < pgrid[i].length; b++ ){
  //   print(pgrid[i][b]);
  //  } 
  //  println("");
  // }

  if (player.place.y < 3) {
    end = true;
  }
  if (player.isDead()) {
    background(255, 0, 0);
  } else {
    for (int xdir = 0; xdir<worldOne.length; xdir++) {
      for (int ydir = 0; ydir<worldOne[0].length; ydir++) {
        worldOne[xdir][ydir].draw(xdir, ydir, squaresize);
      }
    }
    
  for(TetrisBlock blocksu: blocks) {
    blocksu.draw();
  }
    player.draw();
  }
  }
  else {
    text("Epic Win", width/2, height/2);
    this.isDone = true;
  }
}


}


  public void settings() { size(640, 480); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "MiniGameGame" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
